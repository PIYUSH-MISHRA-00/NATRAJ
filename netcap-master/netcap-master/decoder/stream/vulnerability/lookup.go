/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package vulnerability

import (
	"github.com/blevesearch/bleve"
	"github.com/dreadl0ck/netcap/decoder/db"
	"github.com/dreadl0ck/netcap/types"
	"go.uber.org/zap"
)

// VulnerabilitiesLookup searches for known vulnerabilities in the indexed bleve database
// TODO:
// - Make the threshold configurable on the commandline
// - add caching layer to avoid repeating matching operations.
func VulnerabilitiesLookup(software *types.Software) {

	if software == nil {
		return
	}
	if software.Version == "" {
		return
	}

	if db.VulnerabilitiesIndex == nil {
		return
	}

	var (
		queryTerm          = buildNVDQuery(software.Vendor, software.Product, software.Version)
		query              = bleve.NewQueryStringQuery(queryTerm)
		search             = bleve.NewSearchRequest(query)
		searchResults, err = db.VulnerabilitiesIndex.Search(search)
	)

	if err != nil {
		vulnLog.Error("failed to search for vulnerable software", zap.Error(err))

		return
	}

	vulnLog.Info("query vuln database", zap.String("query", queryTerm))

	for _, v := range searchResults.Hits {
		if v.Score > ThresholdNVD {
			doc, _ := db.VulnerabilitiesIndex.Document(v.ID)
			writeVuln(software, doc)
		}
	}
}
