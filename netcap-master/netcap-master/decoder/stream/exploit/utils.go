/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package exploit

import (
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/blevesearch/bleve"
	"github.com/blevesearch/bleve/document"
	"github.com/dreadl0ck/netcap/decoder/db"
	"github.com/dreadl0ck/netcap/types"
	"go.uber.org/zap"
)

const thresholdExploits = 2

type exploitStore struct {
	sync.Mutex
	items map[string]struct{}
}

var expStore = exploitStore{
	items: make(map[string]struct{}),
}

// ExploitsLookup searches for known exploits in the indexed bleve database
// TODO:
// - Make the threshold configurable on the commandline
// - add caching layer to avoid repeating matching operations.
func ExploitsLookup(software *types.Software) {
	if software == nil {
		return
	}

	if software.Version == "" {
		return
	}

	if db.ExploitsIndex == nil {
		return
	}

	var (
		queryTerm          = buildExploitQuery(software.Vendor, software.Product, software.Version)
		query              = bleve.NewQueryStringQuery(queryTerm)
		search             = bleve.NewSearchRequest(query)
		searchResults, err = db.ExploitsIndex.Search(search)
	)

	exploitLog.Info("query exploit database", zap.String("query", queryTerm))

	if err != nil {
		exploitLog.Info("failed to search for vulnerable software", zap.Error(err))

		return
	}

	// fmt.Println("search for ", software.Product, software.Vendor, software.Version)

	for _, v := range searchResults.Hits {
		if v.Score > thresholdExploits {
			doc, _ := db.ExploitsIndex.Document(v.ID)
			writeExploit(software, doc)
		}
	}
}

func buildExploitQuery(vendor, software, version string) string {
	var b strings.Builder

	if len(vendor) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(vendor)
		b.WriteString("\"")
		b.WriteString(" ")
	}
	if len(software) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(software)
		b.WriteString("\"")
		b.WriteString(" ")
	}
	if len(version) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(version)
		b.WriteString("\"")
		b.WriteString(" ")
	}

	return b.String()
}

func writeExploit(software *types.Software, doc *document.Document) {
	// use exploitDB numeric ID as index
	id := string(doc.Fields[0].Value())

	expStore.Lock()
	if _, ok := expStore.items[id]; ok {
		expStore.Unlock()
		// exists, exit.
		return
	} else {
		expStore.items[id] = struct{}{}
	}
	expStore.Unlock()

	// spew.Dump("exploit", doc.Fields)

	atomic.AddInt64(&Decoder.NumRecordsWritten, 1)

	err := Decoder.Writer.Write(&types.Exploit{
		Timestamp:   software.Timestamp,
		ID:          id,
		Description: strings.Trim(string(doc.Fields[2].Value()), "\""),
		File:        filepath.Join("exploitdb", string(doc.Fields[1].Value())),
		Date:        string(doc.Fields[3].Value()),
		Author:      string(doc.Fields[4].Value()),
		Typ:         string(doc.Fields[5].Value()),
		Platform:    string(doc.Fields[6].Value()),
		Port:        string(doc.Fields[7].Value()),
		Software:    software,
	})
	if err != nil {
		exploitLog.Error("failed to flush exploit audit record", zap.Error(err))
	}
}
