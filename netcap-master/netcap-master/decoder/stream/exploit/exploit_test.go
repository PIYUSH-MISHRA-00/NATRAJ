/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package exploit

import (
	"fmt"
	"path/filepath"
	"testing"

	"github.com/blevesearch/bleve"
	"github.com/mgutz/ansi"

	"github.com/dreadl0ck/netcap/decoder/db"
	"github.com/dreadl0ck/netcap/decoder/stream/vulnerability"
	"github.com/dreadl0ck/netcap/logger"
	"github.com/dreadl0ck/netcap/resolvers"
	"github.com/dreadl0ck/netcap/types"
)

/*
 * Exploit Database
 * https://www.exploit-db.com
 */

func init() {
	dbLog, _, err := logger.InitZapLogger("../../tests", "db", false)
	if err != nil {
		panic(err)
	}

	db.SetLogger(dbLog)
}

const debugExploitTests = false

var testSoftware = []*types.Software{
	{
		Product: "PostgreSQL",
		Version: "9.1.0",
	},
	{
		Product: "OpenSSH",
		Version: "7.6",
	},
	{
		Product: "OpenSSH",
		Version: "7.6p1",
	},
	{
		Product: "OpenSSH",
		Version: "7.9",
	},
	{
		Vendor:  "Windows",
		Product: "SSH",
		Version: "7.7",
	},
	{
		Product: "Microsoft-IIS",
		Version: "10.0",
	},
	{
		Product: "Microsoft-CryptoAPI",
		Version: "10.0",
	},
	{
		Product: "NetDNA-cache",
		Version: "2.2",
	},
	{
		Product: "Edge",
		Version: "18.18363",
	},
	{
		Product: "Apache",
		Version: "2.4.38",
	},
	{
		Product: "Windows-Update-Agent",
		Version: "10.0.10011",
	},
	{
		Product: "Chrome",
		Vendor:  "Google",
		Version: "26.0.1410",
	},
	{
		Product: "Apache",
		Version: "2.4.7",
	},
	{
		Product: "Apache",
		Version: "2.4.38",
	},
	{
		Product: "NginX",
		Version: "1.14.0",
	},
	{
		Product: "PHP",
		Version: "7.0",
	},
	{
		Product: "vsFTP",
		Version: "3.0.3",
	},
}

func exploitDBLookupTest(software *types.Software) *bleve.SearchResult {
	var (
		queryTerm = buildExploitQuery(software.Vendor, software.Product, software.Version)
		query     = bleve.NewQueryStringQuery(queryTerm)
		// query = bleve.NewMatchQuery("Google Chrome")
		search             = bleve.NewSearchRequest(query)
		searchResults, err = db.ExploitsIndex.Search(search)
	)
	if debugExploitTests {
		fmt.Println("query:", queryTerm)
	}
	if err != nil {
		fmt.Println("failed to search for vulnerable software:", err)
		return nil
	}
	return searchResults
}

func TestExploitSearch(t *testing.T) {
	// Load vulnerabilities DB index
	var (
		indexName = filepath.Join(resolvers.DataBaseFolderPath, "exploit-db.bleve")
		err       error
	)
	db.ExploitsIndex, err = db.OpenBleve(indexName)
	if err != nil {
		t.Fatal(err)
	}
	defer db.CloseBleve(db.ExploitsIndex)

	// TODO: ensure only numeric values in versions
	// +Description:"Sucuri" +Versions:Cloudproxy ?

	for _, s := range testSoftware {

		if debugExploitTests {
			fmt.Println("lookup software", s.Vendor, s.Product, s.Version)
		}
		searchResults := exploitDBLookupTest(s)
		if searchResults == nil {
			t.Fatal("no results")
		}

		// fmt.Println("search for ", software.Product, software.Vendor, software.Version)

		if debugExploitTests {
			for _, v := range searchResults.Hits {

				var color string
				doc, _ := db.ExploitsIndex.Document(v.ID)
				if v.Score > vulnerability.ThresholdNVD {
					color = ansi.Red
				}
				fmt.Println(ansi.Yellow, v.ID, "score", v.Score, ansi.Reset)
				for i, f := range doc.Fields {
					fmt.Println(color, i, f.Name(), string(f.Value()), ansi.Reset)
				}
				fmt.Println("---------------------------------------------------------")
			}
		}
	}
}
